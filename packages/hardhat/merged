``` ./Makefile
-include .env
.PHONY: all test clean deploy-anvil
all: clean remove install update build
# Clean the repo
clean  :; forge clean
# Remove modules
```

``` ./contracts/AccessRestriction.sol
pragma solidity 0.8.26;
import { AccessControl } from "@openzeppelin/contracts/access/AccessControl.sol";
import { Pausable } from "@openzeppelin/contracts/utils/Pausable.sol";
import { IAccessRestriction } from "./interfaces/IAccessRestriction.sol";
contract AccessRestriction is AccessControl, Pausable, IAccessRestriction {
	bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
	bytes32 public constant SCRIPT_ROLE = keccak256("SCRIPT_ROLE");
	bytes32 public constant ARBITER_ROLE = keccak256("ARBITER_ROLE");
	bytes32 public constant DAO_ROLE = keccak256("DAO_ROLE");
	bytes32 public constant APPROVED_CONTRACT_ROLE =
		keccak256("APPROVED_CONTRACT_ROLE");
	modifier onlyOwner() {
		if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {
			revert NotOwner(msg.sender);
		}
		_;
	}
	constructor(address _deployer) {
		if (!hasRole(DEFAULT_ADMIN_ROLE, _deployer)) {
			_grantRole(DEFAULT_ADMIN_ROLE, _deployer);
		}
	}
	function pause() external override onlyOwner {
		_pause();
	}
	function unpause() external override onlyOwner {
		_unpause();
	}
	function ifOwner(address _address) external view override {
		if (!isOwner(_address)) {
			revert NotOwner(_address);
		}
	}
	function ifAdmin(address _address) external view override {
		if (!isAdmin(_address)) {
			revert NotAdmin(_address);
		}
	}
	function ifOwnerOrAdmin(address _address) external view override {
		if (!isOwner(_address) && !isAdmin(_address)) {
			revert NotAdminOrOwner(_address);
		}
	}
	function ifAdminOrApprovedContract(
		address _address
	) external view override {
		if (!isApprovedContract(_address) && !isAdmin(_address)) {
			revert NotAdminOrApprovedContract(_address);
		}
	}
	function ifAdminOrScript(address _address) external view override {
		if (!isScript(_address) && !isAdmin(_address)) {
			revert NotAdminOrScript(_address);
		}
	}
	function ifApprovedContract(address _address) external view override {
		if (!isApprovedContract(_address)) {
			revert NotApprovedContract(_address);
		}
	}
	function ifScript(address _address) external view override {
		if (!isScript(_address)) {
			revert NotScript(_address);
		}
	}
	function ifArbiter(address _address) external view override {
		if (!isArbiter(_address)) {
			revert NotArbiter(_address);
		}
	}
	function ifDAO(address _address) external view override {
		if (!isDAO(_address)) {
			revert NotDAO(_address);
		}
	}
	function ifNotPaused() external view override {
		if (paused()) {
			revert ContractPaused();
		}
	}
	function ifPaused() external view override {
		if (!paused()) {
			revert ContractNotPaused();
		}
	}
	function paused()
		public
		view
		virtual
		override(Pausable, IAccessRestriction)
		returns (bool)
	{
		return super.paused();
	}
	function isOwner(address _address) public view override returns (bool) {
		return hasRole(DEFAULT_ADMIN_ROLE, _address);
	}
	function isAdmin(address _address) public view override returns (bool) {
		return hasRole(ADMIN_ROLE, _address);
	}
	function isApprovedContract(
		address _address
	) public view override returns (bool) {
		return hasRole(APPROVED_CONTRACT_ROLE, _address);
	}
	function isScript(address _address) public view override returns (bool) {
		return hasRole(SCRIPT_ROLE, _address);
	}
	function isArbiter(address _address) public view override returns (bool) {
		return hasRole(ARBITER_ROLE, _address);
	}
	function isDAO(address _address) public view override returns (bool) {
		return hasRole(DAO_ROLE, _address);
	}
}
```

``` ./contracts/DisputeResolution.sol
pragma solidity 0.8.26;
import { IUserIdentity } from "./interfaces/IUserIdentity.sol";
import { IEscrow } from "./interfaces/IEscrow.sol";
import { IInspection } from "./interfaces/IInspection.sol";
import { ISocialFi } from "./interfaces/ISocialFi.sol";
import { IReputation } from "./interfaces/IReputation.sol";
import { IDisputeResolution } from "./interfaces/IDisputeResolution.sol";
import { IRentalDAO } from "./interfaces/IRentalDAO.sol";
import { IRentalAgreement } from "./interfaces/IRentalAgreement.sol";
import { IAccessRestriction } from "./interfaces/IAccessRestriction.sol";
contract DisputeResolution is IDisputeResolution {
	bytes32 public constant ARBITER_ROLE = keccak256("ARBITER_ROLE");
	mapping(uint256 => Dispute) public disputes;
	IRentalAgreement public rentalAgreement;
	IReputation public reputation;
	IUserIdentity public userIdentity;
	IAccessRestriction public accessRestriction;
	uint256 public constant REPUTATION_PENALTY = 50;
	uint256 public constant VALIDATION_REVOCATION_THRESHOLD = 3;
	modifier onlyArbiter() {
		if (!accessRestriction.isAdmin(msg.sender)) revert NotArbiter(msg.sender);
		_;
	}
	modifier onlyAdmin() {
		if (!accessRestriction.isAdmin(msg.sender)) revert NotAdmin(msg.sender);
		_;
	}
	constructor(
		address _rentalAgreement,
		address _reputation,
		address _userIdentity,
		address _accessRestriction
	) {
		if (_rentalAgreement == address(0))
			revert InvalidAddress("rental agreement");
		if (_reputation == address(0)) revert InvalidAddress("reputation");
		if (_userIdentity == address(0)) revert InvalidAddress("user identity");
		if (_accessRestriction == address(0))
			revert InvalidAddress("access restriction");
		rentalAgreement = IRentalAgreement(_rentalAgreement);
		reputation = IReputation(_reputation);
		userIdentity = IUserIdentity(_userIdentity);
		accessRestriction = IAccessRestriction(_accessRestriction);
	}
	function initiateDispute(uint256 _agreementId) external {
		if (disputes[_agreementId].isActive)
			revert DisputeAlreadyExists(_agreementId);
		disputes[_agreementId].isActive = true;
		emit DisputeInitiated(_agreementId);
	}
	function voteOnDispute(
		uint256 _agreementId,
		bool _voteForRentee
	) external onlyArbiter {
		Dispute storage dispute = disputes[_agreementId];
		if (!dispute.isActive) revert NoActiveDispute(_agreementId);
		if (dispute.hasVoted[msg.sender])
			revert ArbiterAlreadyVoted(msg.sender, _agreementId);
		if (_voteForRentee) {
			dispute.votesForRentee++;
		} else {
			dispute.votesForRenter++;
		}
		dispute.hasVoted[msg.sender] = true;
		emit ArbitersVoted(_agreementId, msg.sender, _voteForRentee);
	}
	function resolveDispute(uint256 _agreementId) external onlyArbiter {
		Dispute storage dispute = disputes[_agreementId];
		if (!dispute.isActive) revert NoActiveDispute(_agreementId);
		(address rentee, address renter) = rentalAgreement.getAgreementParties(
			_agreementId
		);
		address winner;
		address loser;
		if (dispute.votesForRentee > dispute.votesForRenter) {
			winner = rentee;
			loser = renter;
		} else {
			winner = renter;
			loser = rentee;
		}
		reputation.updateReputation(
			_agreementId,
			winner,
			int256(REPUTATION_PENALTY)
		);
		reputation.updateReputation(
			_agreementId,
			loser,
			-int256(REPUTATION_PENALTY)
		);
		if (
			reputation.getReputation(loser) <=
			-int256(VALIDATION_REVOCATION_THRESHOLD * REPUTATION_PENALTY)
		) {
			userIdentity.revokeUser(loser);
		}
		dispute.isActive = false;
		emit DisputeResolved(_agreementId, winner, loser);
	}
	function addArbiter(address _arbiter) external onlyAdmin {
		if (_arbiter == address(0)) revert InvalidAddress("arbiter");
		accessRestriction.grantRole(ARBITER_ROLE, _arbiter);
	}
	function removeArbiter(address _arbiter) external onlyAdmin {
		accessRestriction.revokeRole(ARBITER_ROLE, _arbiter);
	}
	function getDispute(
		uint256 _disputeId
	) external view returns (bool, uint256, uint256) {
		Dispute storage dispute = disputes[_disputeId];
		return (
			dispute.isActive,
			dispute.votesForRentee,
			dispute.votesForRenter
		);
	}
}
```

``` ./contracts/Escrow.sol
pragma solidity 0.8.26;
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IEscrow } from "./interfaces/IEscrow.sol";
import { IAccessRestriction } from "./interfaces/IAccessRestriction.sol";
import { IRentalDAO } from "./interfaces/IRentalDAO.sol";
contract Escrow is IEscrow, ReentrancyGuard, IAccessRestriction, IRentalDAO {
	using SafeERC20 for IERC20;
	mapping(uint256 => bool) public escrows;
	mapping(uint256 => uint256) public agreementEarnings;
	IERC20 public token;
	IRentalDAO public rentalDAO;
	uint256 public feeAmount;
	IAccessRestriction public accessRestriction;
	modifier onlyApprovedContract() {
		accessRestriction.ifApprovedContract(msg.sender);
		_;
	}
	constructor(
		IERC20 _token,
		address _rentalDAO,
		uint256 _feeAmount,
		address _accessRestriction
	) {
		rentalDAO = IRentalDAO(_rentalDAO);
		accessRestriction = IAccessRestriction(_accessRestriction);
		token = _token;
		feeAmount = _feeAmount;
	}
	function lockFunds(
		uint256 _agreementId,
		uint256 _deposit,
		uint256 _cost
	) external onlyApprovedContract nonReentrant {
		if (escrows[_agreementId]) revert Funds_already_locked();
		uint256 systemFee = rentalDAO.getSystemFee();
		uint256 totalAmount = _cost + _deposit;
		token.safeTransferFrom(msg.sender, address(this), totalAmount);
		token.safeTransfer(address(rentalDAO), feeAmount);
		escrows[_agreementId] = true;
		emit FundsLocked(_agreementId);
	}
	function distributeRevenue(
		uint256 _agreementId,
		uint256 _deposit,
		uint256 _cost,
		address _rentee,
		address _renter
	) external {
		if (_deposit <= 0) revert MustBeGraterThanZero("deposit");
		uint256 systemFee = rentalDAO.getSystemFee();
		uint256 renteeEarnings = _cost - systemFee;
		agreementEarnings[_agreementId] = renteeEarnings;
		token.safeTransfer(_renter, _deposit);
		token.safeTransfer(_rentee, renteeEarnings);
		emit RevenueDistributed(_agreementId, renteeEarnings);
	}
	function refundDeposit(
		uint256 _agreementId,
		uint256 _deposit,
		uint256 _cost,
		address _rentee,
		address _renter
	) external onlyApprovedContract nonReentrant {
		if (!escrows[_agreementId]) revert No_deposit_to_refund();
		uint256 systemFee = rentalDAO.getSystemFee();
		uint256 renteeEarnings = _cost - systemFee;
		token.safeTransfer(_renter, _deposit);
		token.safeTransfer(_rentee, renteeEarnings);
		emit DepositRefunded(_agreementId);
	}
	function getEarnings(uint256 _agreementId) external view returns (uint256) {
		return agreementEarnings[_agreementId];
	}
}
```

``` ./contracts/Inspection.sol
pragma solidity 0.8.26;
import { IInspection } from "./interfaces/IInspection.sol";
contract Inspection is IInspection {
	mapping(uint256 => bool) public inspectionResults;
	function inspectItem(uint256 _agreementId) external returns (bool) {
		bool passed = (block.timestamp % 2 == 0);
		inspectionResults[_agreementId] = passed;
		emit ItemInspected(_agreementId, passed);
		return passed;
	}
}
```

``` ./contracts/RentalAgreement.sol
pragma solidity 0.8.26;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IUserIdentity } from "./interfaces/IUserIdentity.sol";
import { IEscrow } from "./interfaces/IEscrow.sol";
import { IInspection } from "./interfaces/IInspection.sol";
import { ISocialFi } from "./interfaces/ISocialFi.sol";
import { IReputation } from "./interfaces/IReputation.sol";
import { IDisputeResolution } from "./interfaces/IDisputeResolution.sol";
import { IRentalDAO } from "./interfaces/IRentalDAO.sol";
import { IRentalAgreement } from "./interfaces/IRentalAgreement.sol";
import { IAccessRestriction } from "./interfaces/IAccessRestriction.sol";
contract RentalAgreement is IRentalAgreement {
	using SafeERC20 for IERC20;
	mapping(address => User) public users;
	mapping(uint256 => Agreement) public agreements;
	mapping(uint256 => Asset) public assets;
	uint256 public agreementCounter;
	IERC20 public token;
	IEscrow public escrow;
	IInspection public inspection;
	IReputation public reputation;
	IDisputeResolution public disputeResolution;
	ISocialFi public socialFi;
	IUserIdentity public userIdentity;
	IRentalDAO public rentalDAO;
	IAccessRestriction public accessRestriction;
	modifier onlyVerifiedUser(address _user) {
		if (_user == address(0) || !userIdentity.isVerifiedUser(_user)) {
			revert UserNotVerified(_user);
		}
		_;
	}
	constructor(
		IERC20 _token,
		address _escrow,
		address _inspection,
		address _reputation,
		address _disputeResolution,
		address _socialFi,
		address _userIdentity,
		address _rentalDAO
	) {
		if (_escrow == address(0)) revert InvalidAddress("escrow");
		if (_inspection == address(0)) revert InvalidAddress("inspection");
		if (_reputation == address(0)) revert InvalidAddress("reputation");
		if (_disputeResolution == address(0))
			revert InvalidAddress("disputeResolution");
		if (_socialFi == address(0)) revert InvalidAddress("socialFi");
		if (_userIdentity == address(0)) revert InvalidAddress("userIdentity");
		if (_rentalDAO == address(0)) revert InvalidAddress("rentalDAO");
		token = _token;
		escrow = IEscrow(_escrow);
		inspection = IInspection(_inspection);
		reputation = IReputation(_reputation);
		disputeResolution = IDisputeResolution(_disputeResolution);
		socialFi = ISocialFi(_socialFi);
		userIdentity = IUserIdentity(_userIdentity);
		rentalDAO = IRentalDAO(_rentalDAO);
	}
	modifier onlyOwner() {
		accessRestriction.ifOwner(msg.sender);
		_;
	}
	function createAgreement(
		address _renter,
		uint256 _tokenId,
		uint256 _rentalPeriod,
		uint256 _cost,
		uint256 _deposit
	)
		external
		onlyVerifiedUser(msg.sender)
		onlyVerifiedUser(_renter)
		returns (uint256)
	{
		if (_cost <= 0) revert MustBeGraterThanZero("cost");
		if (_deposit <= 0) revert MustBeGraterThanZero("deposit");
		if (_rentalPeriod <= 0) revert MustBeGraterThanZero("rentalPeriod");
		Asset storage asset = assets[_tokenId];
		if (!asset.isActive) revert AssetIsNotActive();
		agreements[agreementCounter] = Agreement({
			rentee: users[msg.sender],
			renter: users[address(0)],
			asset: asset,
			rentalPeriod: _rentalPeriod,
			cost: _cost,
			deposit: _deposit,
			startTime: 0,
			registrationTime: block.timestamp,
			status: AgreementStatus.CREATED,
			isDisputed: false
		});
		agreementCounter++;
		emit AgreementCreated(agreementCounter, msg.sender, _renter);
		return agreementCounter;
	}
	function ArrivalAgreement(uint256 _agreementId) external {
		Agreement storage agreement = agreements[_agreementId];
		if (
			agreement.renter.userAddress != address(0) ||
			agreement.isDisputed ||
			agreement.status != AgreementStatus.CREATED
		) {
			revert InvalidAgreement();
		}
		uint256 totalAmount = agreement.cost + agreement.deposit;
		if (IERC20(token).balanceOf(msg.sender) < totalAmount)
			revert InsufficientBalance(
				IERC20(token).balanceOf(msg.sender),
				totalAmount
			);
		if (!agreement.asset.isActive) revert AssetIsNotActive();
		escrow.lockFunds(_agreementId, agreement.cost, agreement.deposit);
		agreement.asset.timesRented++;
		agreement.renter = users[msg.sender];
		agreement.startTime = block.timestamp;
		agreement.status = AgreementStatus.REQUESTED;
		emit ArrivalAgreementEvent(
			_agreementId,
			agreement.rentee.userAddress,
			agreement.renter.userAddress,
			block.timestamp
		);
	}
	function completeAgreement(uint256 _agreementId) external {
		Agreement storage agreement = agreements[_agreementId];
		if (
			msg.sender != agreement.rentee.userAddress &&
			msg.sender != agreement.renter.userAddress
		) {
			revert NotAuthorized();
		}
		if (agreement.status != AgreementStatus.STARTED)
			revert AgreementNotActive();
		if (block.timestamp <= agreement.startTime + agreement.rentalPeriod)
			revert RentalPeriodNotOver(
				block.timestamp,
				agreement.startTime + agreement.rentalPeriod
			);
		bool isItemInGoodCondition = inspection.inspectItem(_agreementId);
		if (!isItemInGoodCondition)
			revert InspectionFailed(
				isItemInGoodCondition,
				agreement.rentee.userAddress,
				agreement.renter.userAddress
			);
		agreement.status = AgreementStatus.COMPLETED;
		socialFi.rewardUser(agreement.rentee.userAddress, 100);
		socialFi.rewardUser(agreement.renter.userAddress, 100);
		escrow.distributeRevenue(
			_agreementId,
			agreement.deposit,
			agreement.cost,
			agreement.rentee.userAddress,
			agreement.renter.userAddress
		);
		emit AgreementCompleted(_agreementId);
		escrow.refundDeposit(
			_agreementId,
			agreement.deposit,
			agreement.cost,
			agreement.rentee.userAddress,
			agreement.renter.userAddress
		);
	}
	function cancelAgreement(uint256 _agreementId) external {
		Agreement storage agreement = agreements[_agreementId];
		if (msg.sender != agreement.renter.userAddress) {
			revert NotAuthorized();
		}
		if (agreement.status != AgreementStatus.STARTED)
			revert AgreementNotActive();
		agreement.status = AgreementStatus.CANCELLED;
		emit AgreementCancelled(_agreementId);
		escrow.refundDeposit(
			_agreementId,
			agreement.deposit,
			agreement.cost,
			agreement.rentee.userAddress,
			agreement.renter.userAddress
		);
	}
	function raiseDispute(uint256 _agreementId) external {
		Agreement storage agreement = agreements[_agreementId];
		if (
			msg.sender != agreement.rentee.userAddress &&
			msg.sender != agreement.renter.userAddress
		) revert NotAuthorized();
		if (agreement.status != AgreementStatus.STARTED)
			revert AgreementNotActive();
		emit DisputeRaised(_agreementId);
		disputeResolution.initiateDispute(_agreementId);
	}
	function extendRentalPeriodRentee(
		uint256 _agreementId,
		uint256 _additionalPeriod,
		uint256 _newCost
	) external {
		Agreement storage agreement = agreements[_agreementId];
		if (msg.sender != agreement.rentee.userAddress) {
			revert NotAuthorized();
		}
		if (agreement.status != AgreementStatus.STARTED) {
			revert AgreementNotActive();
		}
		agreement.rentalPeriod += _additionalPeriod;
		agreement.cost = _newCost;
		emit AgreementExtendedRentee(
			_agreementId,
			agreement.rentalPeriod,
			_newCost
		);
	}
	function extendRentalPeriodRenter(
		uint256 _agreementId,
		uint256 _additionalPeriod
	) external {
		Agreement storage agreement = agreements[_agreementId];
		if (msg.sender != agreement.renter.userAddress) {
			revert NotAuthorized();
		}
		if (agreement.status != AgreementStatus.STARTED) {
			revert AgreementNotActive();
		}
		agreement.rentalPeriod += _additionalPeriod;
		emit AgreementExtendedRenter(_agreementId, agreement.rentalPeriod);
	}
	function updateEscrow(address _escrow) external onlyOwner {
		if (_escrow == address(0)) revert InvalidAddress("escrow");
		escrow = IEscrow(_escrow);
	}
	function updateInspection(address _inspection) external onlyOwner {
		if (_inspection == address(0)) revert InvalidAddress("inspection");
		inspection = IInspection(_inspection);
	}
	function updateReputation(address _reputation) external onlyOwner {
		if (_reputation == address(0)) revert InvalidAddress("reputation");
		reputation = IReputation(_reputation);
	}
	function updateDisputeResolution(
		address _disputeResolution
	) external onlyOwner {
		if (_disputeResolution == address(0))
			revert InvalidAddress("dispute resolution");
		disputeResolution = IDisputeResolution(_disputeResolution);
	}
	function updateSocialFi(address _socialFi) external onlyOwner {
		socialFi = ISocialFi(_socialFi);
	}
	function updateUserIdentity(address _userIdentity) external onlyOwner {
		userIdentity = IUserIdentity(_userIdentity);
	}
	function updateDAO(address _rentalDAO) external onlyOwner {
		if (_rentalDAO == address(0)) revert InvalidDAOAddress(_rentalDAO);
		rentalDAO = IRentalDAO(_rentalDAO);
	}
	function getAgreementParties(
		uint256 _agreementId
	) external view returns (address rentee, address renter) {}
}
```

``` ./contracts/RentalDAO.sol
pragma solidity 0.8.26;
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { IRentalDAO } from "./interfaces/IRentalDAO.sol";
import { IAccessRestriction } from "./interfaces/IAccessRestriction.sol";
contract RentalDAO is IRentalDAO, ReentrancyGuard {
	bytes32 public constant DAO_ROLE = keccak256("DAO_ROLE");
	uint256 public systemFee; // Fee in basis points (1/100 of a percent)
	uint256 public constant MAX_FEE = 1000; // 10% max fee
	IAccessRestriction public accessRestriction;
	mapping(string => address) private contractAddresses;
	modifier onlyDAO() {
		if (!accessRestriction.isDAO(msg.sender)) revert notDAO();
		_;
	}
	modifier onlyAdmin() {
		if (!accessRestriction.isAdmin(msg.sender)) revert NotAdmin();
		_;
	}
	constructor(address _accessRestriction, uint256 _initialFee) {
		if (_initialFee > MAX_FEE) revert FeeExceedsMaximum(_initialFee);
		systemFee = _initialFee;
		accessRestriction = IAccessRestriction(_accessRestriction);
	}
	function proposeAndUpdateSystemFee(uint256 _newFee) external onlyDAO {
		if (_newFee > MAX_FEE) revert FeeExceedsMaximum(_newFee);
		uint256 oldFee = systemFee;
		systemFee = _newFee;
		emit SystemFeeUpdated(oldFee, _newFee);
	}
	function addDAOMember(address _member) external onlyAdmin {
		if (_member == address(0)) revert InvalidAddress();
		accessRestriction.grantRole(DAO_ROLE, _member);
	}
	function removeDAOMember(address _member) external onlyAdmin {
		if (_member == address(0)) revert InvalidAddress();
		accessRestriction.revokeUser(DAO_ROLE, _member);
	}
	function getSystemFee() external view returns (uint256) {
		return systemFee;
	}
	function withdrawFees(
		address payable _recipient,
		uint256 _amount
	) external onlyAdmin nonReentrant {
		if (_recipient == address(0)) revert InvalidAddress();
		if (_amount > address(this).balance)
			revert InsufficientBalance(address(this).balance, _amount);
		_recipient.transfer(_amount);
	}
	function updateContractAddress(
		string memory _contractName,
		address _newAddress
	) external onlyAdmin {
		if (_newAddress == address(0)) revert InvalidAddress();
		contractAddresses[_contractName] = _newAddress;
	}
	function getContractAddress(
		string memory _contractName
	) external view returns (address) {
		return contractAddresses[_contractName];
	}
}
```

``` ./contracts/Reputation.sol
pragma solidity 0.8.26;
import "@openzeppelin/contracts/access/AccessControl.sol";
import { IReputation } from "./interfaces/IReputation.sol";
contract Reputation is IReputation, AccessControl {
	bytes32 public constant UPDATER_ROLE = keccak256("UPDATER_ROLE");
	mapping(address => int256) public reputationScores;
	function updateReputation(
		uint256 _agreementId,
		address _user,
		int256 _change
	) external onlyRole(UPDATER_ROLE) {
		if (_user == address(0)) revert InvalidAddress(_user);
		reputationScores[_user] += _change;
		emit ReputationUpdated(
			_agreementId,
			_user,
			_change,
			reputationScores[_user]
		);
	}
	function getReputation(address _user) external view returns (int256) {
		return reputationScores[_user];
	}
	function addUpdater(
		address _updater
	) external onlyRole(DEFAULT_ADMIN_ROLE) {
		if (_updater == address(0)) revert InvalidUpdaterAddress(_updater);
		grantRole(UPDATER_ROLE, _updater);
	}
	function removeUpdater(
		address _updater
	) external onlyRole(DEFAULT_ADMIN_ROLE) {
		revokeRole(UPDATER_ROLE, _updater);
	}
}
```

``` ./contracts/SocialFi.sol
pragma solidity 0.8.26;
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { ISocialFi } from "./interfaces/ISocialFi.sol";
contract SocialFi is ISocialFi, ReentrancyGuard {
	using SafeERC20 for IERC20;
	IERC20 public token;
	constructor(IERC20 _token) {
		token = _token;
	}
	mapping(address => uint256) public rewards;
	function rewardUser(address _user, uint256 _amount) external {
		if (_amount <= 0) revert MustBeGraterThanZero("amount");
		rewards[_user] += _amount;
		emit UserRewarded(_user, _amount);
	}
	function getRewardBalance(address _user) external view returns (uint256) {
		return rewards[_user];
	}
	function claimRewards() external {
		uint256 amount = rewards[msg.sender];
		if (amount <= 0) revert NoRewardsToClaim();
		rewards[msg.sender] = 0;
		token.safeTransfer(msg.sender, amount);
	}
}
```

``` ./contracts/UserIdentity.sol
pragma solidity 0.8.26;
import { IUserIdentity } from "./interfaces/IUserIdentity.sol";
import { IAccessRestriction } from "./interfaces/IAccessRestriction.sol";
contract UserIdentity is IUserIdentity {
	mapping(address => bool) public verifiedUsers;
	address public admin;
	IAccessRestriction public accessRestriction;
	modifier onlyAdmin() {
		if (!accessRestriction.isAdmin(msg.sender)) revert NotAdmin(msg.sender);
		_;
	}
	constructor(address _accessRestriction) {
		admin = msg.sender;
		accessRestriction = IAccessRestriction(_accessRestriction);
	}
	function verifyUser(address _user) external onlyAdmin {
		if (verifiedUsers[_user]) revert UserAlreadyVerified(_user);
		verifiedUsers[_user] = true;
		emit UserVerified(_user);
	}
	function revokeUser(address _user) external onlyAdmin {
		if (!verifiedUsers[_user]) revert UserNotVerified(_user);
		verifiedUsers[_user] = false;
		emit UserRevoked(_user);
	}
	function isVerifiedUser(address _user) external view returns (bool) {
		return verifiedUsers[_user];
	}
	function transferAdmin(address _newAdmin) external onlyAdmin {
		if (_newAdmin == address(0)) revert InvalidAddress("_newAdmin");
		admin = _newAdmin;
	}
}
```

``` ./contracts/interfaces/IAccessRestriction.sol
pragma solidity 0.8.26;
import { IAccessControl } from "@openzeppelin/contracts/access/IAccessControl.sol";
import { ICommonErrors } from "./ICommonErrors.sol";
interface IAccessRestriction is IAccessControl, ICommonErrors {
	error NotAdminOrOwner(address caller);
	error NotAdminOrApprovedContract(address caller);
	error NotAdminOrScript(address caller);
	error NotApprovedContract(address caller);
	error NotScript(address caller);
	error NotArbiter(address caller);
	error NotDAO(address caller);
	error ContractPaused();
	error ContractNotPaused();
	function pause() external;
	function unpause() external;
	function ifOwner(address _address) external view;
	function ifAdmin(address _address) external view;
	function ifOwnerOrAdmin(address _address) external view;
	function ifAdminOrApprovedContract(address _address) external view;
	function isOwner(address _address) external view returns (bool);
	function isAdmin(address _address) external view returns (bool);
	function ifApprovedContract(address _address) external view;
	function isApprovedContract(address _address) external view returns (bool);
	function isScript(address _address) external view returns (bool);
	function isArbiter(address _address) external view returns (bool);
	function isDAO(address _address) external view returns (bool);
	function ifScript(address _address) external view;
	function ifArbiter(address _address) external view;
	function ifDAO(address _address) external view;
	function ifAdminOrScript(address _address) external view;
	function ifNotPaused() external view;
	function ifPaused() external view;
	function paused() external view returns (bool);
}
```

``` ./contracts/interfaces/ICommonErrors.sol
pragma solidity 0.8.26;
interface ICommonErrors {
	error NotOwner(address caller);
	error NotAdmin(address caller);
	error InvalidAddress(string field);
	error NotAuthorized();
	error MustBeGraterThanZero(string param);
	error InsufficientBalance(uint256 available, uint256 required);
}
```

``` ./contracts/interfaces/IDisputeResolution.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface IDisputeResolution is ICommonErrors {
    struct Dispute {
        bool isActive;
        uint256 votesForRentee;
        uint256 votesForRenter;
        mapping(address => bool) hasVoted;
    }
    event DisputeInitiated(uint256 agreementId);
    event DisputeResolved(uint256 agreementId, address winner, address loser);
    event ArbitersVoted(
        uint256 agreementId,
        address arbiter,
        bool votedForRentee
    );
    error DisputeAlreadyExists(uint256 agreementId);
    error NoActiveDispute(uint256 agreementId);
    error ArbiterAlreadyVoted(address arbiter, uint256 agreementId);
    error NotArbiter(address caller);
    function initiateDispute(uint256 _agreementId) external;
    function voteOnDispute(uint256 _agreementId, bool _voteForRentee) external;
    function resolveDispute(uint256 _agreementId) external;
    function addArbiter(address _arbiter) external;
    function removeArbiter(address _arbiter) external;
    function getDispute(
        uint256 _disputeId
    ) external view returns (bool isActive, uint256 votesForRentee, uint256 votesForRenter);
}
```

``` ./contracts/interfaces/IEscrow.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface IEscrow is ICommonErrors {
	struct EscrowDetails {
		uint256 lockedFunds;
		uint256 deposit;
		address owner;
		address renter;
	}
	event RevenueDistributed(uint256 agreementId, uint256 amount);
	event FundsLocked(uint256 agreementId);
	event FundsReleased(uint256 agreementId, uint256 amount, address recipient);
	event DepositRefunded(uint256 agreementId);
	error Funds_already_locked();
	error Incorrect_amount_sent();
	error Invalid_sender_address();
	error No_funds_locked_for_this_agreement();
	error No_funds_to_release();
	error Renter_already_confirmed();
	error No_deposit_to_refund();
	error Not_authorized();
	function lockFunds(
		uint256 _agreementId,
		uint256 _deposit,
		uint256 _cost
	) external;
	function distributeRevenue(
		uint256 _agreementId,
		uint256 _deposit,
		uint256 _cost,
		address _rentee,
		address _renter
	) external;
	function refundDeposit(
		uint256 _agreementId,
		uint256 _deposit,
		uint256 _cost,
		address _rentee,
		address _renter
	) external;
	function getEarnings(uint256 _agreementId) external view returns (uint256);
	function agreementEarnings(
		uint256 _agreementId
	) external view returns (uint256);
}
```

``` ./contracts/interfaces/IInspection.sol
pragma solidity 0.8.26;
interface IInspection {
	event ItemInspected(uint256 agreementId, bool passed);
	function inspectItem(uint256 _agreementId) external returns (bool);
	function inspectionResults(
		uint256 _agreementId
	) external view returns (bool);
}
```

``` ./contracts/interfaces/IRentalAgreement.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface IRentalAgreement is ICommonErrors {
	struct User {
		address userAddress;
		uint256 validationTime;
		bool isValidated;
		uint256 reputationScore;
		uint256 joinTime;
	}
	struct Collection {
		address collection;
		string name;
	}
	struct Asset {
		Collection assetAddress;
		string name;
		string assetType;
		bool isActive;
		uint256 timesRented;
	}
	struct Agreement {
		User rentee;
		User renter;
		Asset asset;
		uint256 rentalPeriod;
		uint256 cost;
		uint256 deposit;
		uint256 startTime;
		uint256 registrationTime;
		AgreementStatus status;
		bool isDisputed;
	}
	enum AgreementStatus {
		CREATED,
		REQUESTED,
		STARTED,
		COMPLETED,
		CANCELLED
	}
	error InvalidAgreement();
	error Asset_is_not_active();
	error UserNotVerified(address user);
	error AssetIsNotActive();
	error AgreementNotActive();
	error RentalPeriodNotOver(uint256 currentTime, uint256 endTime);
	error InspectionFailed(bool itemCondition, address rentee, address renter);
	error InvalidDAOAddress(address daoAddress);
	event AgreementCreated(uint256 agreementId, address rentee, address renter);
	event AgreementCompleted(uint256 agreementId);
	event DisputeRaised(uint256 agreementId);
	event AgreementCancelled(uint256 agreementId);
	event AgreementExtendedRentee(
		uint256 _agreementId,
		uint256 _rentalPeriod,
		uint256 _newCost
	);
	event AgreementExtendedRenter(uint256 _agreementId, uint256 _rentalPeriod);
	event ArrivalAgreementEvent(
		uint256 agreementId,
		address rentee,
		address renter,
		uint256 arrivalTime
	);
	function createAgreement(
		address _renter,
		uint256 _tokenId,
		uint256 _rentalPeriod,
		uint256 _cost,
		uint256 _deposit
	) external returns (uint256);
	function ArrivalAgreement(uint256 _agreementId) external;
	function completeAgreement(uint256 _agreementId) external;
	function cancelAgreement(uint256 _agreementId) external;
	function raiseDispute(uint256 _agreementId) external;
	function extendRentalPeriodRentee(
		uint256 _agreementId,
		uint256 _additionalPeriod,
		uint256 _newCost
	) external;
	function extendRentalPeriodRenter(
		uint256 _agreementId,
		uint256 _additionalPeriod
	) external;
	function updateEscrow(address _escrow) external;
	function updateInspection(address _inspection) external;
	function updateReputation(address _reputation) external;
	function updateDisputeResolution(address _disputeResolution) external;
	function updateSocialFi(address _socialFi) external;
	function updateUserIdentity(address _userIdentity) external;
	function updateDAO(address _rentalDAO) external;
	function getAgreementParties(
		uint256 _agreementId
	) external view returns (address rentee, address renter);
}
```

``` ./contracts/interfaces/IRentalDAO.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface IRentalDAO is ICommonErrors {
	event SystemFeeUpdated(uint256 oldFee, uint256 newFee);
	event FeesWithdrawn(address recipient, uint256 amount);
	event ContractAddressUpdated(string contractName, address newAddress);
	error FeeExceedsMaximum(uint256 fee);
	error Unauthorized();
	error OnlyDAO();
	error OnlyAdmin();
	function proposeAndUpdateSystemFee(uint256 _newFee) external;
	function addDAOMember(address _member) external;
	function removeDAOMember(address _member) external;
	function getSystemFee() external view returns (uint256);
	function withdrawFees(address payable _recipient, uint256 _amount) external;
	function updateContractAddress(
		string memory _contractName,
		address _newAddress
	) external;
	function getContractAddress(
		string memory _contractName
	) external view returns (address);
}
```

``` ./contracts/interfaces/IReputation.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface IReputation is ICommonErrors {
	event ReputationUpdated(
		uint256 agreementId,
		address user,
		int256 change,
		int256 newScore
	);
	error InvalidAddress(address user);
	error InvalidUpdaterAddress(address updater);
	function updateReputation(
		uint256 _agreementId,
		address _user,
		int256 _change
	) external;
	function getReputation(address _user) external view returns (int256);
	function addUpdater(address _updater) external;
	function removeUpdater(address _updater) external;
}
```

``` ./contracts/interfaces/ISocialFi.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface ISocialFi is ICommonErrors {
	event UserRewarded(address indexed user, uint256 amount);
	error NoRewardsToClaim();
	function rewardUser(address _user, uint256 _amount) external;
	function getRewardBalance(address _user) external view returns (uint256);
	function claimRewards() external;
}
```

``` ./contracts/interfaces/IUserIdentity.sol
pragma solidity 0.8.26;
import { ICommonErrors } from "./ICommonErrors.sol";
interface IUserIdentity is ICommonErrors {
	event UserVerified(address indexed user);
	event UserRevoked(address indexed user);
	error UserAlreadyVerified(address user);
	error UserNotVerified(address user);
	function verifyUser(address _user) external;
	function revokeUser(address _user) external;
	function isVerifiedUser(address _user) external view returns (bool);
	function transferAdmin(address _newAdmin) external;
}
```

``` ./deploy/01_deploy.ts
import { HardhatRuntimeEnvironment } from "hardhat/types";
import { DeployFunction } from "hardhat-deploy/types";
const deployContracts: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const { deploy } = hre.deployments;
  const { deployer } = await hre.getNamedAccounts();
  const userIdentity = await deploy("UserIdentity", {
    from: deployer,
    log: true,
  });
  const reputation = await deploy("Reputation", {
    from: deployer,
    log: true,
  });
  const monetization = await deploy("Monetization", {
    from: deployer,
    log: true,
  });
  const socialFi = await deploy("SocialFi", {
    from: deployer,
    log: true,
  });
  const inspection = await deploy("Inspection", {
    from: deployer,
    log: true,
  });
  const disputeResolution = await deploy("DisputeResolution", {
    from: deployer,
    log: true,
  });
  const escrow = await deploy("Escrow", {
    from: deployer,
    log: true,
  });
  await deploy("RentalAgreement", {
    from: deployer,
    args: [
      escrow.address,
      inspection.address,
      reputation.address,
      disputeResolution.address,
      socialFi.address,
      monetization.address,
      userIdentity.address,
    ],
    log: true,
  });
};
export default deployContracts;
deployContracts.tags = ["RentalAgreement"];
```

``` ./deploy/99_generateTsAbis.ts
import * as fs from "fs";
import prettier from "prettier";
import { DeployFunction } from "hardhat-deploy/types";
const generatedContractComment = `
`;
const DEPLOYMENTS_DIR = "./deployments";
const ARTIFACTS_DIR = "./artifacts";
function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}
function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}
function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const contractContent = sources[sourcePath].content as string;
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);
      if (match) {
        const inheritancePart = match[2];
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);
        return inheritedContracts;
      }
      return [];
    }
  }
  return [];
}
function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {} as Record<string, any>;
  for (const sourceContractName of actualSources) {
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
    if (sourcePath) {
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
      const { abi } = JSON.parse(fs.readFileSync(`${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`).toString());
      for (const functionAbi of abi) {
        if (functionAbi.type === "function") {
          inheritedFunctions[functionAbi.name] = sourcePath;
        }
      }
    }
  }
  return inheritedFunctions;
}
function getContractDataFromDeployments() {
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    throw Error("At least one other deployment script should exist to generate an actual contract.");
  }
  const output = {} as Record<string, any>;
  for (const chainName of getDirectories(DEPLOYMENTS_DIR)) {
    const chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
    const contracts = {} as Record<string, any>;
    for (const contractName of getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`)) {
      const { abi, address, metadata } = JSON.parse(
        fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`).toString(),
      );
      const inheritedFunctions = getInheritedFunctions(JSON.parse(metadata).sources, contractName);
      contracts[contractName] = { address, abi, inheritedFunctions };
    }
    output[chainId] = contracts;
  }
  return output;
}
const generateTsAbis: DeployFunction = async function () {
  const TARGET_DIR = "../nextjs/contracts/";
  const allContractsData = getContractDataFromDeployments();
  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }
  const formattedContent = await prettier.format(
    `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
    {
      parser: "typescript",
    },
  );
  fs.writeFileSync(`${TARGET_DIR}deployedContracts.ts`, formattedContent);
  console.log(`📝 Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
};
export default generateTsAbis;
generateTsAbis.tags = ["generateTsAbis"];
generateTsAbis.runAtTheEnd = true;
```

``` ./foundry.toml
[profile.default]
src = 'contracts'
out = 'out'
libs = ['node_modules', 'lib']
test = 'test'
cache_path  = 'cache_forge'
```

``` ./hardhat.config.ts
import * as dotenv from "dotenv";
dotenv.config();
import { HardhatUserConfig } from "hardhat/config";
import fs from "fs";
import "@nomicfoundation/hardhat-toolbox";
import "@nomicfoundation/hardhat-foundry";
import "@truffle/dashboard-hardhat-plugin";
import "hardhat-preprocessor";
import "@nomicfoundation/hardhat-ethers";
import "@nomicfoundation/hardhat-chai-matchers";
import "@typechain/hardhat";
import "hardhat-gas-reporter";
import "solidity-coverage";
import "@nomicfoundation/hardhat-verify";
import "hardhat-deploy";
import "hardhat-deploy-ethers";
const providerApiKey = process.env.ALCHEMY_API_KEY || "oKxs-03sij-U_N0iOlrSsZFr29-IqbuF";
const deployerPrivateKey =
  process.env.DEPLOYER_PRIVATE_KEY ?? "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
const etherscanApiKey = process.env.ETHERSCAN_API_KEY || "DNXJA8RX2Q3VZ4URQIWP7Z68CJXQZSC6AW";
function getRemappings() {
  return fs
    .readFileSync("remappings.txt", "utf8")
    .split("\n")
    .filter(Boolean)
    .map((line: string) => line.trim().split("="));
}
interface MyHardhatUserConfig extends HardhatUserConfig {
  preprocess?: {
    eachLine: (_hre: any) => {
      transform: (line: string) => string;
    };
  };
}
const config: MyHardhatUserConfig = {
  solidity: {
    version: "0.8.26",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  defaultNetwork: "localhost",
  namedAccounts: {
    deployer: {
      default: 0,
    },
  },
  networks: {
    hardhat: {
      forking: {
        url: `https://eth-mainnet.alchemyapi.io/v2/${providerApiKey}`,
        enabled: process.env.MAINNET_FORKING_ENABLED === "true",
      },
    },
    mainnet: {
      url: `https://eth-mainnet.alchemyapi.io/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    sepolia: {
      url: `https://eth-sepolia.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    arbitrum: {
      url: `https://arb-mainnet.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    arbitrumSepolia: {
      url: `https://arb-sepolia.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    optimism: {
      url: `https://opt-mainnet.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    optimismSepolia: {
      url: `https://opt-sepolia.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    polygon: {
      url: `https://polygon-mainnet.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    polygonMumbai: {
      url: `https://polygon-mumbai.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    polygonZkEvm: {
      url: `https://polygonzkevm-mainnet.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    polygonZkEvmTestnet: {
      url: `https://polygonzkevm-testnet.g.alchemy.com/v2/${providerApiKey}`,
      accounts: [deployerPrivateKey],
    },
    gnosis: {
      url: "https://rpc.gnosischain.com",
      accounts: [deployerPrivateKey],
    },
    chiado: {
      url: "https://rpc.chiadochain.net",
      accounts: [deployerPrivateKey],
    },
    base: {
      url: "https://mainnet.base.org",
      accounts: [deployerPrivateKey],
    },
    baseSepolia: {
      url: "https://sepolia.base.org",
      accounts: [deployerPrivateKey],
    },
    scrollSepolia: {
      url: "https://sepolia-rpc.scroll.io",
      accounts: [deployerPrivateKey],
    },
    scroll: {
      url: "https://rpc.scroll.io",
      accounts: [deployerPrivateKey],
    },
    pgn: {
      url: "https://rpc.publicgoods.network",
      accounts: [deployerPrivateKey],
    },
    pgnTestnet: {
      url: "https://sepolia.publicgoods.network",
      accounts: [deployerPrivateKey],
    },
    shibarium: {
      url: "https://rpc.shibrpc.com",
      accounts: [deployerPrivateKey],
      chainId: 157,
    },
    crossfi: {
      url: "https://rpc.testnet.ms",
      accounts: [deployerPrivateKey],
      chainId: 4157,
    },
    "truffle-dashboard": {
      url: "http://localhost:24012/rpc",
    },
  },
  etherscan: {
    apiKey: `${etherscanApiKey}`,
  },
  verify: {
    etherscan: {
      apiKey: `${etherscanApiKey}`,
    },
  },
  sourcify: {
    enabled: false,
  },
  preprocess: {
    eachLine: (_hre: any) => ({
      transform: (line: string) => {
        if (line.match(/^\s*import /i)) {
          getRemappings().forEach(([find, replace]) => {
            if (line.match(find)) {
              line = line.replace(find, replace);
            }
          });
        }
        return line;
      },
    }),
  },
};
export default config;
```

``` ./package.json
{
  "name": "@se-2/hardhat",
  "version": "0.0.1",
  "scripts": {
    "account": "hardhat run scripts/listAccount.ts",
    "chain": "hardhat node --network hardhat --no-deploy",
    "compile": "hardhat compile",
    "deploy": "hardhat deploy",
    "fork": "MAINNET_FORKING_ENABLED=true hardhat node --network hardhat --no-deploy",
    "generate": "hardhat run scripts/generateAccount.ts",
    "flatten": "hardhat flatten",
    "test": "REPORT_GAS=true hardhat test --network hardhat",
    "verify": "hardhat etherscan-verify",
    "hardhat-verify": "hardhat verify",
    "clean": "rm -rf ./artifacts && rm -rf ./cache && rm -rf ./hardhat-deploy && rm -rf ./deployments && rm -rf ./typechain-types && forge clean",
    "anvil": "make anvil",
    "build": "forge build",
    "ftest": "forge test",
    "fdeploy": "make deploy-anvil",
    "dashboard": "truffle dashboard",
    "tdeploy": "hardhat deploy --network truffle-dashboard --export-all ./temp/hardhat_contracts.json \"$@\" && hardhat run utils/generateTsAbis.ts"
  },
  "devDependencies": {
    "@ethersproject/abi": "^5.7.0",
    "@ethersproject/providers": "^5.7.1",
    "@nomicfoundation/hardhat-chai-matchers": "^2.0.3",
    "@nomicfoundation/hardhat-ethers": "^3.0.5",
    "@nomicfoundation/hardhat-foundry": "^1.1.2",
    "@nomicfoundation/hardhat-ignition": "^0.15.5",
    "@nomicfoundation/hardhat-ignition-ethers": "^0.15.5",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.6",
    "@nomicfoundation/hardhat-toolbox": "^5.0.0",
    "@nomicfoundation/hardhat-verify": "^2.0.3",
    "@nomicfoundation/ignition-core": "^0.15.5",
    "@truffle/dashboard-hardhat-plugin": "^0.2.15",
    "@typechain/ethers-v5": "^10.1.0",
    "@typechain/hardhat": "^9.1.0",
    "@types/eslint": "^8",
    "@types/mocha": "^9.1.1",
    "@types/prettier": "^2",
    "@types/qrcode": "^1",
    "@typescript-eslint/eslint-plugin": "latest",
    "@typescript-eslint/parser": "latest",
    "chai": "^4.3.6",
    "eslint": "^8.26.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "ethers": "^6.10.0",
    "hardhat": "^2.19.4",
    "hardhat-deploy": "^0.11.45",
    "hardhat-deploy-ethers": "^0.4.1",
    "hardhat-gas-reporter": "^1.0.9",
    "hardhat-preprocessor": "^0.1.5",
    "prettier": "^3.3.2",
    "solidity-coverage": "^0.8.5",
    "truffle": "^5.11.5",
    "ts-node": "^10.9.1",
    "typechain": "^8.1.0",
    "typescript": "^5.1.6"
  },
  "dependencies": {
    "@openzeppelin/contracts": "^5.0.2",
    "@typechain/ethers-v6": "^0.5.1",
    "dotenv": "^16.0.3",
    "envfile": "^6.18.0",
    "qrcode": "^1.5.1"
  }
}
```

``` ./remappings.txt
ds-test/=lib/forge-std/lib/ds-test/src/
forge-std/=lib/forge-std/src/
```

``` ./scripts/YourContract.s.sol
pragma solidity ^0.8.13;
import "forge-std/Script.sol";
import {YourContract} from "../contracts/YourContract.sol";
contract DeployYourContract is Script {
  function setUp() public {}
  function run() public {
    vm.startBroadcast();
    new YourContract(address(0x1));
    vm.stopBroadcast();
  }
}
```

``` ./scripts/generateAccount.ts
import { ethers } from "ethers";
import { parse, stringify } from "envfile";
import * as fs from "fs";
const envFilePath = "./.env";
const setNewEnvConfig = (existingEnvConfig = {}) => {
  console.log("👛 Generating new Wallet");
  const randomWallet = ethers.Wallet.createRandom();
  const newEnvConfig = {
    ...existingEnvConfig,
    DEPLOYER_PRIVATE_KEY: randomWallet.privateKey,
  };
  fs.writeFileSync(envFilePath, stringify(newEnvConfig));
  console.log("📄 Private Key saved to packages/hardhat/.env file");
  console.log("🪄 Generated wallet address:", randomWallet.address);
};
async function main() {
  if (!fs.existsSync(envFilePath)) {
    setNewEnvConfig();
    return;
  }
  const existingEnvConfig = parse(fs.readFileSync(envFilePath).toString());
  if (existingEnvConfig.DEPLOYER_PRIVATE_KEY) {
    console.log("⚠️ You already have a deployer account. Check the packages/hardhat/.env file");
    return;
  }
  setNewEnvConfig(existingEnvConfig);
}
main().catch(error => {
  console.error(error);
  process.exitCode = 1;
});
```

``` ./scripts/generateTsAbis.ts
import * as fs from "fs";
import allGeneratedContracts from "../temp/hardhat_contracts.json";
import prettier from "prettier";
async function main() {
  const TARGET_DIR = "../nextjs/generated/";
  const fileContent = Object.entries(allGeneratedContracts).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }
  fs.writeFileSync(
    `${TARGET_DIR}deployedContracts.ts`,
    await prettier.format(`const contracts = {${fileContent}} as const; \n\n export default contracts`, {
      parser: "typescript",
    }),
  );
  fs.rmSync("./temp", { recursive: true, force: true });
}
try {
  main();
} catch (error) {
  console.error(error);
  process.exitCode = 1;
}
```

``` ./scripts/listAccount.ts
import * as dotenv from "dotenv";
dotenv.config();
import { ethers, Wallet } from "ethers";
import QRCode from "qrcode";
import { config } from "hardhat";
async function main() {
  const privateKey = process.env.DEPLOYER_PRIVATE_KEY;
  if (!privateKey) {
    console.log("🚫️ You don't have a deployer account. Run `yarn generate` first");
    return;
  }
  const wallet = new Wallet(privateKey);
  const address = wallet.address;
  console.log(await QRCode.toString(address, { type: "terminal", small: true }));
  console.log("Public address:", address, "\n");
  const availableNetworks = config.networks;
  for (const networkName in availableNetworks) {
    try {
      const network = availableNetworks[networkName];
      if (!("url" in network)) continue;
      const provider = new ethers.JsonRpcProvider(network.url);
      await provider._detectNetwork();
      const balance = await provider.getBalance(address);
      console.log("--", networkName, "-- 📡");
      console.log("   balance:", +ethers.formatEther(balance));
      console.log("   nonce:", +(await provider.getTransactionCount(address)));
    } catch (e) {
      console.log("Can't connect to network", networkName);
    }
  }
}
main().catch(error => {
  console.error(error);
  process.exitCode = 1;
});
```

``` ./test/foundry/YourContract.t.sol
pragma solidity ^0.8.13;
import "forge-std/Test.sol";
import "../../contracts/YourContract.sol";
contract YourContractTest is Test {
  address test = address(0x123);
  YourContract public yourContract;
  function setUp() public {
    yourContract = new YourContract(test);
  }
  function testDeployment() public {
    assertEq(yourContract.greeting(), "Building Unstoppable Apps!!!");
  }
  function testSetGreetig(string memory greeting) public {
    yourContract.setGreeting(greeting);
    assertEq(yourContract.greeting(), greeting);
  }
}
```

``` ./tsconfig.json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```
